package main

import (
	"os"
	"log"
	"path"
	"bufio"
	"errors"
	"fmt"
)

type _CodeResult struct {
	name string
	err error
}

type _CodeConfig struct {
	packageName string
	touchTimestamp bool
}

func generateModels(dbName string, dbSchema _DbSchema, config _CodeConfig) {
	if fs, err := os.Stat(config.packageName); err != nil || !fs.IsDir() {
		os.Mkdir(config.packageName, os.ModeDir | os.ModePerm)
	}

	jobs := make(chan _CodeResult)
	for tbl, cols := range dbSchema {
		go func(tableName string, schema _TableSchema) {
			err := generateModel(dbName, tableName, schema, config)
			jobs <- _CodeResult{tableName, err}
		}(tbl, cols)
	}

	for i := 0; i < len(dbSchema); i++ {
		result := <- jobs
		if result.err != nil {
			log.Printf("Error when generating code for %s, %s", result.name, result.err)
		} else {
			log.Printf("Code generated for table %s, into package %s/%s.go", result.name, config.packageName, result.name)
		}
	}
	close(jobs)
}

func generateModel(dbName, tName string, schema _TableSchema, config _CodeConfig) error {
	file, err := os.Create(path.Join(config.packageName, tName + ".go"))
	if err != nil {
		return err
	}
	w := bufio.NewWriter(file)

	defer func () {
		w.Flush()
		file.Close()
	}()
	
	if err := writeCodeHeader(w, dbName, tName, config.packageName); err != nil {
		return errors.New(fmt.Sprintf("[%s] Error when writing the header into file.", tName))
	}

	return nil
}

func writeCodeHeader(w *bufio.Writer, dbName, tName, pName string) error {
	tmpl := `// Code generated by modelq, %s
// %s.go contains model for the database table [%s.%s]

package %s

`
	_, err := w.WriteString(fmt.Sprintf(tmpl, "20141011", tName, dbName, tName, pName))
	return err
}